/*
 * Microservicio de Contenido - UnderSounds
 *
 * Este microservicio gestiona el contenido multimedia y comercial del proyecto \"UnderSounds\", incluyendo albumes, canciones, generos, merchandising y noticias musicales.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"database/sql"
	"fmt"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
)

type AlbumesAPI struct {
	DB *sql.DB
}

// Get /albums
// Listar albumes con filtros opcionales
func (api *AlbumesAPI) AlbumsGet(c *gin.Context) {
	albums, err := GetAllAlbums(api.DB)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{
		"status": "OK",
		"albums": albums,
	})
}

// Delete /albums/:id
// Eliminar un album
func (api *AlbumesAPI) AlbumsIdDelete(c *gin.Context) {
	idParam := c.Param("id")
	var id int32
	_, err := fmt.Sscan(idParam, &id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
		return
	}

	err = DeleteAlbum(api.DB, id)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"status": "error", "message": "Album no encontrado"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"status":  "OK",
		"message": "Album eliminado correctamente",
	})
}

// Patch /albums/:id/disminuirStockAlbum
// Disminuir la cantidad disponible de un album
func (api *AlbumesAPI) AlbumsIdDisminuirStockAlbumPatch(c *gin.Context) {
	// Your handler implementation
	c.JSON(http.StatusNotImplemented, gin.H{"status": "not_implemented"})
}

// Get /albums/:id
// Obtener detalles de un album
func (api *AlbumesAPI) AlbumsIdGet(c *gin.Context) {
	idParam := c.Param("id")
	var id int32
	_, err := fmt.Sscan(idParam, &id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
		return
	}

	album, err := GetAlbum(api.DB, id)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"status": "error", "message": "Album no encontrado"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"status": "OK",
		"album":  album,
	})
}

// Patch /albums/:id
// Actualizar un album existente
func (api *AlbumesAPI) AlbumsIdPatch(c *gin.Context) {
	idParam := c.Param("id")
	var id int32
	_, err := fmt.Sscan(idParam, &id)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "ID inválido"})
		return
	}

	var req UpdateAlbumRequest
	contentType := c.GetHeader("Content-Type")

	// Soportar JSON o multipart/form-data
	if strings.Contains(contentType, "multipart/form-data") {
		// Parsear formulario multipart
		if err := c.Request.ParseMultipartForm(MaxImageSize); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Error parseando formulario"})
			return
		}

		// Leer campos opcionales del form
		if nombre := c.PostForm("nombre"); nombre != "" {
			req.Nombre = &nombre
		}
		if urlImagen := c.PostForm("urlImagen"); urlImagen != "" {
			req.UrlImagen = &urlImagen
		}
		if fecha := c.PostForm("fecha"); fecha != "" {
			req.Fecha = &fecha
		}
		if durStr := c.PostForm("duracion"); durStr != "" {
			var dur int32
			if _, err := fmt.Sscan(durStr, &dur); err == nil {
				req.Duracion = &dur
			}
		}
		if genStr := c.PostForm("genero"); genStr != "" {
			var gen int32
			if _, err := fmt.Sscan(genStr, &gen); err == nil {
				req.Genero = &gen
			}
		}
		if artStr := c.PostForm("artista"); artStr != "" {
			var art int32
			if _, err := fmt.Sscan(artStr, &art); err == nil {
				req.Artista = &art
			}
		}

		// Procesar archivo de portada si existe
		if _, err := c.FormFile("cover"); err == nil {
			// Obtener el álbum actual para saber el artista
			currentAlbum, err := GetAlbum(api.DB, id)
			if err != nil {
				c.JSON(http.StatusNotFound, gin.H{"error": "Album no encontrado"})
				return
			}

			// Guardar portada
			coverURL, err := SaveUploadedCover(c, "cover", currentAlbum.Artista, id)
			if err != nil {
				c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("Error subiendo portada: %s", err.Error())})
				return
			}
			req.UrlImagen = &coverURL
		}

	} else {
		// Leer body JSON
		if err := c.ShouldBindJSON(&req); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "JSON inválido"})
			return
		}
	}

	// Llamada al modelo
	updatedAlbum, err := req.UpdateAlbum(api.DB, id)
	if err != nil {
		if err == sql.ErrNoRows {
			c.JSON(http.StatusNotFound, gin.H{"status": "error", "message": "Album no encontrado"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": err.Error()})
		return
	}

	// Respuesta exitosa
	c.JSON(http.StatusOK, gin.H{
		"status": "OK",
		"album":  updatedAlbum,
	})
}

// Patch /albums/:id/recargarStockAlbum
// Aumentar la cantidad disponible de un album
func (api *AlbumesAPI) AlbumsIdRecargarStockAlbumPatch(c *gin.Context) {
	// Your handler implementation
	c.JSON(http.StatusNotImplemented, gin.H{"status": "not_implemented"})
}

// Post /albums
// Crear un nuevo album
func (api *AlbumesAPI) AlbumsPost(c *gin.Context) {
	var req CreateAlbumRequest
	contentType := c.GetHeader("Content-Type")

	// Soportar JSON o multipart/form-data
	if strings.Contains(contentType, "multipart/form-data") {
		// Parsear formulario multipart
		if err := c.Request.ParseMultipartForm(MaxImageSize); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Error parseando formulario multipart"})
			return
		}

		// Leer campos del formulario
		req.Nombre = c.PostForm("nombre")
		req.UrlImagen = c.PostForm("urlImagen")
		req.Fecha = c.PostForm("fecha")

		// Convertir duracion (opcional)
		if durStr := c.PostForm("duracion"); durStr != "" {
			var dur int32
			if _, err := fmt.Sscan(durStr, &dur); err == nil {
				req.Duracion = &dur
			}
		}

		// Convertir genero
		var generoID int32
		if _, err := fmt.Sscan(c.PostForm("genero"), &generoID); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "genero inválido"})
			return
		}
		req.Genero = generoID

		// Convertir artista
		var artistaID int32
		if _, err := fmt.Sscan(c.PostForm("artista"), &artistaID); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "artista inválido"})
			return
		}
		req.Artista = artistaID

		// Validar nombre (requerido)
		if req.Nombre == "" {
			c.JSON(http.StatusBadRequest, gin.H{"error": "el campo 'nombre' es requerido"})
			return
		}

	} else {
		// Parsear JSON tradicional
		if err := c.ShouldBindJSON(&req); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "JSON inválido"})
			return
		}
	}

	// Crear album en la BD
	nuevoAlbum, err := req.CreateAlbum(api.DB)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": err.Error()})
		return
	}

	// Si hay archivo de portada en multipart, procesarlo
	if strings.Contains(contentType, "multipart/form-data") {
		if _, err := c.FormFile("cover"); err == nil {
			// Guardar portada
			coverURL, err := SaveUploadedCover(c, "cover", nuevoAlbum.Artista, nuevoAlbum.Id)
			if err != nil {
				// Si falla la subida, eliminar el álbum creado
				DeleteAlbum(api.DB, nuevoAlbum.Id)
				c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("Error subiendo portada: %s", err.Error())})
				return
			}

			// Actualizar urlImagen en la BD
			updateReq := UpdateAlbumRequest{UrlImagen: &coverURL}
			nuevoAlbum, err = updateReq.UpdateAlbum(api.DB, nuevoAlbum.Id)
			if err != nil {
				c.JSON(http.StatusInternalServerError, gin.H{"status": "error", "message": "Error actualizando URL de portada"})
				return
			}
		}
	}

	c.JSON(http.StatusCreated, gin.H{
		"status": "OK",
		"album":  nuevoAlbum,
	})
}
